\section{Тест производительности}
Сравнивать производительность буду с супер наивной реализацией, в ней все отрезки складываются в вектор, затем при выполнении запроса происходит обход всего вектора и подсчёт количества отрезков.
Тесты производительности буду проводить с помощью различных наборов данных:

\begin{enumerate}
    \item 10 отрезков и 10 запросов
    \item 50 отрезков и 50 запросов
    \item 200 отрезков и 200 запросов
    \item 20 отрезков и 200 запросов
    \item 200 отрезков и 20 запросов
\end{enumerate}

\begin{alltt}
    alext@alext-pc solution]$ ./naive < test10.txt 
    Super naive time: 37us
    [alext@alext-pc solution]$ ./solution < test10.txt 
    Persistent time: 48us
    alext@alext-pc solution]$ ./naive < test50.txt
    Super naive time: 155us
    [alext@alext-pc solution]$ ./solution < test50.txt 
    Persistent time: 263us
    alext@alext-pc solution]$ ./naive < test200.txt
    Super naive time: 155895us
    [alext@alext-pc solution]$ ./solution < test200.txt
    Persistent time: 22673us
    alext@alext-pc solution]$ ./naive < test20-200.txt
    Super naive time: 2197us
    [alext@alext-pc solution]$ ./solution < test20-200.txt
    Persistent time: 547us
    alext@alext-pc solution]$ ./naive < test200-20.txt
    Super naive time: 149us
    alext@alext-pc solution]$ ./solution < test200-20.txt
    Persistent time: 635us
\end{alltt}

Как видим, решение с использованием персистентных структур данных эффективнее на достаточно больших наборах особенно тогда, когда количество запросов превышает количество данных.

\pagebreak
