\section{Описание}
Требуется реализовать поиск количество отрезков, лежащих строго над точкой, используя персистентные структуры данных.

Задачу я буду решать при помощи алгоритма заметающей прямой. 

Суть решения заключается в следующем: координатная плоскость разбивается на вертикальные полосы таким образом, чтобы каждый отрезок либо пересекал полосу полностью, либо не пересекал её вообще; таким образом, каждая полоса будет отличаться от предыдущей (левее неё) на один отрезок (в новой полосе либо начинается новый отрезок, либо кончается старый); для каждой полосы хранятся отрезки, пересекающие её в отсортированном виде; при осуществлении запроса сначала производится поиск полосы методом бинарного поиска (сложность $O(logn)$, где n --- количество полос), а затем осуществляется поиск в сортированной структуре координаты $y$ точки, что также выполняется за $O(logn)$; и, наконец, подсчитывается количество искомых отрезков.

В качестве отсортированной структуры буду использовать бинарное дерево, но сделаю его персистентным. При добавлении или удалении вершины будет создаваться новый корень, по которому можно будет получить доступ к нужной версии дерева.

Персистентность реализуется следующим образом: при добавлении или удалении вершины создаётся новая ветвь дерева до этой вершины, остальные ветви остаются нетронутыми, в новое дерево переносятся только указатели на их узлы.

\pagebreak

\section{Исходный код}
Опишу класс $TNode$ узла дерева и класс $TTree$ самого дерева. 

В классе дерева корни каждого состояния хранятся в векторе. Реализованы функции добавления и удаления узла, отладочные методы печати дерева на экран, проверки его на корректность добавления и удаления узлов, а также вспомогательные методы для поиска и печати. 

\begin{lstlisting}[language=C]
	struct TNode {
		TNode* Left;
		TNode* Right;
		double Height;
		TNode(double h) {
			Height = h;
			Left = nullptr;
			Right = nullptr;
		}
		~TNode() {}
	};
	
	class TTree {
	public:
		std::vector<TNode*> Roots;
		TTree() {}
		~TTree() {}
	
		void PrintTree(int);
		TNode* AddNode(double);
		TNode* RemNode(double);
		bool Check(double);
		bool Check(double, TNode*);
		void FullCheck();
		void FullCheck(TNode*);
		std::vector<double> Values;
	
	private:
		bool RecFind(TNode*, double &);
		void RecPrintTree(TNode*, int);
	};
	
}
	
\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}
[alext@alext-pc solution]$ make
g++ -std=c++14 -pedantic -Wall -Wextra-Wno-unused-variable lab1.cpp -o solution
[alext@alext-pc solution]$ cat test1 
472891 asakdhfl
130391 bfsadfkjlsdf
891767 csdafKHdf
130000 dkhjs32
[alext@alext-pc solution]$ ./solution <\ test1 
130000	dkhjs32
130391	bfsadfkjlsdf
472891	asakdhfl
891767	csdafKHdf
\end{alltt}
\pagebreak