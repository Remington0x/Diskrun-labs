\section{Описание}
Требуется реализовать поиск количество отрезков, лежащих строго над точкой, используя персистентные структуры данных.

Задачу я буду решать при помощи алгоритма заметающей прямой. 

Суть решения заключается в следующем: координатная плоскость разбивается на вертикальные полосы таким образом, чтобы каждый отрезок либо пересекал полосу полностью, либо не пересекал её вообще; таким образом, каждая полоса будет отличаться от предыдущей (левее неё) на один отрезок (в новой полосе либо начинается новый отрезок, либо кончается старый); для каждой полосы хранятся отрезки, пересекающие её в отсортированном виде; при осуществлении запроса сначала производится поиск полосы методом бинарного поиска (сложность $O(logn)$, где n --- количество полос), а затем осуществляется поиск в сортированной структуре координаты $y$ точки, что также выполняется за $O(logn)$; и, наконец, подсчитывается количество искомых отрезков.

В качестве отсортированной структуры буду использовать бинарное дерево, но сделаю его персистентным. При добавлении или удалении вершины будет создаваться новый корень, по которому можно будет получить доступ к нужной версии дерева.

Персистентность реализуется следующим образом: при добавлении или удалении вершины создаётся новая ветвь дерева до этой вершины, остальные ветви остаются нетронутыми, в новое дерево переносятся только указатели на их узлы.

\pagebreak

\section{Исходный код}
Опишу класс $TNode$ узла дерева и класс $TTree$ самого дерева. 

В классе дерева корни каждого состояния хранятся в векторе. Реализованы функции добавления и удаления узла, отладочные методы печати дерева на экран, проверки его на корректность добавления и удаления узлов, а также вспомогательные методы для поиска и печати. 

В \texttt{main.cpp} описаны структуры полосы и отрезка, реализованы функции вставки в вектор, добавления в отсортированную очередь с сохранением порядка и функция подсчёта элементов всех поддеревьев. В самой функции \texttt{main()} сначала считываются отрезки, затем по ним строится структура данных, далее в цикле считываются точки и выполняются запросы.

\begin{lstlisting}[language=C]
	struct TNode {
		TNode* Left;
		TNode* Right;
		double Height;
		TNode(double h) {
			Height = h;
			Left = nullptr;
			Right = nullptr;
		}
		~TNode() {}
	};
	
	class TTree {
	public:
		std::vector<TNode*> Roots;
		TTree() {}
		~TTree() {}
	
		void PrintTree(int);
		TNode* AddNode(double);
		TNode* RemNode(double);
		bool Check(double);
		bool Check(double, TNode*);
		void FullCheck();
		void FullCheck(TNode*);
		std::vector<double> Values;
	
	private:
		bool RecFind(TNode*, double &);
		void RecPrintTree(TNode*, int);
	};
	
}
\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}
	[alext@alext-pc solution]$ cat test10.txt 
	10 10
	9552 9753 1268
	8813 9028 3090
	2353 2459 6112
	8335 8660 2324
	4764 5612 2174
	823 1050 2027
	6267 6592 9861
	3665 4378 6732
	6551 7493 8248
	1892 2490 3770
	6636 7150
	5971 4256
	2315 8539
	7347 4668
	5997 3459
	9356 5322
	5783 4120
	8171 4309
	4944 1750
	2688 7563
	[alext@alext-pc solution]$ ./solution <\ test10.txt 
	0
	1
	0
	0
	0
	1
	0
	1
	0
	0
	0
\end{alltt}
\pagebreak