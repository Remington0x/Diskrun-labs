\section{Описание}
Требуется реализовать алгоритм Ахо-Корасик. 

Как сказано в \cite{Aho-Kor-ifmo}, задача алгоритма заключается в следующем: \enquote{Дан набор строк в алфавите размера k суммарной длины m. Необходимо найти для каждой строки все ее вхождения в текст}. 

Суть алгоритма заключается в следующем: \\
\textbf{1. Построение бора}\\
Строится бор (нагруженное дерево) из строк образца. Построение выполняется за $O(m)$, где m --- суммарная длина строк.

\textbf{2. Преобразование бора}\\
Алгоритм удобно реализовать в виде конечного автомата. Узлы бора можно понимать, как состояния автомата, а корень как начальное состояние.

Узлы бора, в которых заканчиваются строки, становятся терминальными.

Для переходов по автомату заведём в узлах несколько функций:

$parent(u)$ --- возвращает родителя вершины $u$;

$\pi(u) = \delta(\pi(parent(u)), c)$ --- суффиксная ссылка, и существует переход из $parent(u)$ в $u$ по символу $c$;

$\delta(u, c) = $
$\begin{cases}
v, & if\ v\ is\ son\ by\ symbol\ c\ in\ trie;\\
root, & if\ u\ is\ root\ and\ u\ has\ no\ child\ by\ symbol\ c\ in\ trie;\\
\delta(\pi(u), c), & else.
\end{cases}$

Можно понимать рёбра бора как переходы в автомате по соответствующей букве. Однако если попытаться перейти по букве, для которой нет соответствующего ребра, нас может постигнуть неудача, но такого быть не должно. Для этого существуют суффиксные ссылки.

Суффиксная ссылка $\pi(u) = v$, если $[v]$ --- максимальный суффикс $[u]$, $[v] \neq [u]$.
\\
В нашем случае алгоритм претерпит некоторые изменения. Это связано с тем, что в образце встречаются джокеры. В дерево нужно будет добавить не одну строку образца, а все его подстроки, не содержащие джокеров.

Непосредственно при поиске при проходе по тексту нужно для каждой подстроки без джокеров находить начальные позиции их вхождения в текст. Для каждого такого начала j подстроки $P_i$ в Т увеличиваем счётчик в ячейке $j-l_i+1$ вектора С на единицу. После окончания прохода текста просматриваем вектор С в поисках ячеек со значением, равным k -- числу подстрок образца без джокеров. Вхождение P в текст, начинающееся с позиции p, имеется только в том случае, если $C(p) = k$.

Основными этапами работы программы являются заполнение вектора образца, составление по нему бора, создание ссылок, заполнение вектора текста и совершение поиска за один проход по тексту.


\pagebreak

\section{Исходный код}
Объявление классов узла бора и самого бора.\\
{\ttfamily Trie::Create(patterns)} --- создаёт дерево из вектора patterns.\\
{\ttfamily Trie::Search(text, patLen, answer)} --- ищет вхождения в текст образцов из дерева, выводит ответ в консоль, patLen --- размер вектора образцов.\\

\begin{lstlisting}[language=C]
	class TTrie;

	class TTrieNode {
	public:
		friend class TTrie;
		TTrieNode();
		~TTrieNode() {};
	private:
		std::map<unsigned long, TTrieNode *> to;
		TTrieNode* suffLink;
		std::vector<int> out;
	};
	
	class TTrie {
	public:
		TTrie();
		void Create(const std::vector<std::string> &);
		void Search(const std::vector<unsigned long> &, const int &, std::vector<std::pair<int, int>> &);
		~TTrie() {};
	private:
		TTrieNode *root;
		std::vector<int> lensPatterns;
		int woJoker;
		void CreateLinks();
	};

}
	
\end{lstlisting}

\pagebreak

\section{Консоль}
\begin{alltt}
[alext@alext-pc solution]$ ./solution 
213 ? 8 5 ?
49869 213 5 5 767 564 6969 5 8 8 5 981 8 69 213 8 8 86 5 938
314 8 65 11781 892 22114 9248 4823 44913 63632 8 5 65 5 74 213 13373 8 5 19
8 213 99642 8 5 5 3748 7734 56653 8 8494 5 58 4835 1 56771 213 8 213 62921
9 8152 6 213 213 23791 213 5 213 91167 5 61 8 5 8 5 213 213 64 5
5 8 8 8726 29669 1163 8 213 64987 93 213 8 9996 1 5 8 7156 8 213 7
56711 8 167 135 96 4289 5 58142 286 8 51827 14 213 3388 8341 8 213 24 5 213
8 14 3222 4833 9 213 8 213 5 12 7362 73 963 7 5 213 634 213 5 17678
8 9136 816 27 5 92947 213 89833 278 54646 5 8 87815 8 11729 213 8 93667 8 7186
5 8 35 5 213 213 51278 5 213 45 213 8 8 6 449 8 92 5 5 8
642 213 3345 83 8 3 6682 5 31332 213 213 8 5 7195 8 7159 145 8 213 8

2, 16
3, 2
10, 10

[alext@alext-pc solution]$ ./solution 
1 2 3 4 5 ? ? ? ?
1 2 3 4 5 6 9 12
1 2 3 4 5 7 10 13
1 2 3 4 5 8 11 14

1, 1
2, 1
\end{alltt}
\pagebreak

